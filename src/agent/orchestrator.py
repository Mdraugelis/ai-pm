"""
Agent Orchestrator
Geisinger AI Product Manager Agent - Layer 1: Core Agent Runtime

Main agent loop controller implementing the Geisinger Agentic Architecture.

Agent Loop: Gather → Plan → Act → Verify → Iterate

IMPORTANT ARCHITECTURE:
- SDK Integration: Used ONLY for LLM interface (planning, responses)
- Geisinger Framework: Handles orchestration, verification, HITL, memory
- This orchestrator coordinates ALL layers, SDK is just one component

Following patterns from geisinger-sdk-integrator agent guidance.
"""

import asyncio
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, List, Optional

import structlog

from src.agent.llm_interface import LLMInterface
from src.tools.sdk_tool_adapter import SDKToolAdapter

logger = structlog.get_logger(__name__)


# ============================================================================
# Data Structures
# ============================================================================


@dataclass
class Task:
    """Task for agent to execute"""

    description: str
    initiative_id: Optional[str] = None
    domain: str = "product_management"
    metadata: Dict[str, Any] = None


@dataclass
class Plan:
    """Execution plan generated by agent"""

    steps: List[Dict[str, Any]]
    confidence: float
    reasoning: str
    requires_approval: bool = False


@dataclass
class AgentResponse:
    """Final agent response"""

    status: str  # SUCCESS, FAILED, ESCALATED, MAX_ITERATIONS
    result: Optional[Dict[str, Any]] = None
    verification: Optional[Dict[str, Any]] = None
    trace: List[Dict[str, Any]] = None
    reasoning: List[str] = None
    requires_approval: bool = False
    hitl_tier: Optional[str] = None


# ============================================================================
# Agent Orchestrator
# ============================================================================


class AgentOrchestrator:
    """
    Main agent loop controller

    Implements the Geisinger agent pattern:
    1. GATHER context (from memory, databases, blueprints)
    2. PLAN approach (using LLM via SDK)
    3. ACT (execute tools)
    4. VERIFY (self-check against policies)
    5. ITERATE or ESCALATE

    SDK is used ONLY in step 2 (PLAN) for LLM calls.
    All other logic is pure Geisinger framework.

    Example:
        >>> orchestrator = AgentOrchestrator(config)
        >>> result = await orchestrator.execute_task(task)
    """

    def __init__(
        self,
        config: Dict[str, Any],
        blueprint_loader: Optional[Any] = None,
        tool_registry: Optional[Any] = None,
        memory_manager: Optional[Any] = None,
    ):
        """
        Initialize orchestrator

        Args:
            config: Agent configuration
            blueprint_loader: Blueprint loader (Layer 7: Knowledge)
            tool_registry: Tool registry (Layer 3: Tools)
            memory_manager: Memory manager (Layer 2: Memory)
        """
        self.config = config
        self.blueprint_loader = blueprint_loader
        self.tool_registry = tool_registry
        self.memory_manager = memory_manager

        # Initialize LLM interface (uses SDK internally)
        self.llm = LLMInterface(config, blueprint_loader, tool_registry)

        # Initialize tool adapter for SDK bridge
        self.tool_adapter = SDKToolAdapter()

        # Configuration
        self.max_iterations = config.get("max_iterations", 10)
        self.confidence_threshold = config.get("confidence_threshold", 0.7)

        logger.info(
            "Agent orchestrator initialized",
            max_iterations=self.max_iterations,
            confidence_threshold=self.confidence_threshold,
        )

    async def execute_task(self, task: Task) -> AgentResponse:
        """
        Main agent loop

        Executes: Gather → Plan → Act → Verify → Iterate

        Args:
            task: Task to execute

        Returns:
            AgentResponse with result and trace
        """
        logger.info("Starting task execution", task_description=task.description)

        # Initialize execution trace
        trace = []
        reasoning = []

        # Load blueprints (GATHER step - Geisinger layer)
        meta_blueprint = await self._load_meta_blueprint()
        domain_blueprint = await self._load_domain_blueprint(task.domain)

        # Initialize context (GATHER step - Geisinger layer)
        context = {
            "task": task,
            "meta_blueprint": meta_blueprint,
            "domain_blueprint": domain_blueprint,
            "iteration": 0,
            "conversation": [],
            "tool_results": [],
            "previous_attempts": [],
        }

        # Agent loop
        for iteration in range(self.max_iterations):
            context["iteration"] = iteration

            logger.info("Agent iteration", iteration=iteration)

            # 1. GATHER context (Geisinger layer)
            gathered_context = await self._gather_context(context)
            trace.append(
                {
                    "step": "gather",
                    "iteration": iteration,
                    "context_summary": self._summarize_context(gathered_context),
                }
            )

            # 2. PLAN approach (SDK layer - LLM call)
            plan = await self._create_plan(task, gathered_context)
            trace.append(
                {
                    "step": "plan",
                    "iteration": iteration,
                    "plan": plan,
                    "confidence": plan.confidence,
                }
            )

            reasoning.append(
                f"Iteration {iteration}: {plan.reasoning} (confidence: {plan.confidence:.0%})"
            )

            # 3. ACT - Execute plan (Geisinger layer)
            execution_result = await self._execute_plan(plan, gathered_context)
            trace.append(
                {
                    "step": "execute",
                    "iteration": iteration,
                    "result": execution_result,
                }
            )

            # 4. VERIFY - Self-check (Geisinger layer)
            verification = await self._verify_result(
                execution_result, plan, gathered_context
            )
            trace.append(
                {
                    "step": "verify",
                    "iteration": iteration,
                    "verification": verification,
                }
            )

            # 5. ITERATE/ADAPT or COMPLETE
            if verification.get("complete", False):
                # Task complete!
                logger.info(
                    "Task completed successfully",
                    iterations=iteration + 1,
                    confidence=verification.get("confidence"),
                )

                return AgentResponse(
                    status="SUCCESS",
                    result=execution_result,
                    verification=verification,
                    trace=trace,
                    reasoning=reasoning,
                    requires_approval=verification.get("requires_approval", False),
                    hitl_tier=verification.get("hitl_tier"),
                )

            elif verification.get("should_escalate", False):
                # Escalate to human
                logger.warning(
                    "Task escalated",
                    reason=verification.get("escalation_reason"),
                    iterations=iteration + 1,
                )

                return AgentResponse(
                    status="ESCALATED",
                    result=execution_result,
                    verification=verification,
                    trace=trace,
                    reasoning=reasoning,
                )

            else:
                # Adapt and continue
                context = self._adapt_context(context, verification)
                logger.info("Adapting plan", issues=verification.get("issues"))

        # Max iterations reached
        logger.error("Max iterations reached", max_iterations=self.max_iterations)

        return AgentResponse(
            status="MAX_ITERATIONS",
            trace=trace,
            reasoning=reasoning,
        )

    async def _gather_context(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        GATHER step: Collect all relevant context

        This is PURE Geisinger - no SDK involved.
        Gathers from memory, databases, blueprints, etc.

        Args:
            context: Current context

        Returns:
            Enriched context
        """
        # Placeholder - will connect to memory manager, database, etc.
        gathered = context.copy()

        # Add timestamp
        gathered["timestamp"] = datetime.now().isoformat()

        # Add available tools (from tool registry)
        if self.tool_registry:
            gathered["available_tools"] = self.tool_registry.get_tool_ids()

        return gathered

    async def _create_plan(self, task: Task, context: Dict[str, Any]) -> Plan:
        """
        PLAN step: Generate execution plan

        This USES SDK via LLMInterface for the LLM call,
        but planning logic is Geisinger's.

        Args:
            task: Task to plan for
            context: Execution context

        Returns:
            Plan object
        """
        # Call LLM via SDK integration (SDK's job)
        plan_dict = await self.llm.generate_plan(
            {"description": task.description, "initiative_id": task.initiative_id},
            context,
        )

        # Convert to Geisinger Plan (Geisinger's job)
        plan = Plan(
            steps=plan_dict.get("steps", []),
            confidence=plan_dict.get("confidence", 0.5),
            reasoning=plan_dict.get("reasoning", "LLM generated plan"),
            requires_approval=plan_dict.get("confidence", 0.5)
            < self.confidence_threshold,
        )

        return plan

    async def _execute_plan(
        self, plan: Plan, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        ACT step: Execute the plan

        This is PURE Geisinger - executes tools, manages state.
        No SDK involved.

        Args:
            plan: Plan to execute
            context: Execution context

        Returns:
            Execution result
        """
        # Placeholder - will execute tools from registry
        result = {"status": "executed", "plan_steps": len(plan.steps), "output": {}}

        logger.info("Plan executed", steps=len(plan.steps))

        return result

    async def _verify_result(
        self, result: Dict[str, Any], plan: Plan, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        VERIFY step: Self-check result

        This is PURE Geisinger - verification against policies.
        No SDK involved.

        Args:
            result: Execution result
            plan: Original plan
            context: Execution context

        Returns:
            Verification result with complete/escalate decision
        """
        # Placeholder - will use SelfVerifier from governance layer
        verification = {
            "passed": True,
            "complete": True,  # For now, complete immediately
            "confidence": plan.confidence,
            "checks": [],
            "requires_approval": plan.confidence < self.confidence_threshold,
            "hitl_tier": "TIER_3" if plan.requires_approval else "TIER_1",
        }

        return verification

    def _adapt_context(
        self, context: Dict[str, Any], verification: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Adapt context based on verification feedback

        Args:
            context: Current context
            verification: Verification result

        Returns:
            Adapted context
        """
        adapted = context.copy()

        # Add verification issues to previous attempts
        if "issues" in verification:
            adapted.setdefault("previous_attempts", []).append(verification["issues"])

        return adapted

    async def _load_meta_blueprint(self) -> Dict[str, Any]:
        """Load meta-blueprint (universal policies)"""
        if self.blueprint_loader:
            return self.blueprint_loader.load_meta_blueprint()
        return {}

    async def _load_domain_blueprint(self, domain: str) -> Dict[str, Any]:
        """Load domain-specific blueprint"""
        if self.blueprint_loader:
            return self.blueprint_loader.load_domain_blueprint(domain)
        return {}

    def _summarize_context(self, context: Dict[str, Any]) -> str:
        """Create context summary for trace"""
        return f"Iteration {context.get('iteration', 0)}, {len(context.get('tool_results', []))} tool results"


# ============================================================================
# Module Exports
# ============================================================================

__all__ = [
    "AgentOrchestrator",
    "Task",
    "Plan",
    "AgentResponse",
]
